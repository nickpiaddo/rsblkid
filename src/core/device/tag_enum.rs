// Copyright (c) 2023 Nick Piaddo
// SPDX-License-Identifier: Apache-2.0 OR MIT

// From dependency library

// From standard library
use std::ffi::{CString, NulError};
use std::fmt;
use std::str::FromStr;

// From this library
use crate::core::errors::ConversionError;
use crate::core::errors::EncodeError;
use crate::core::errors::ParserError;

use crate::core::utils::encode::encode_string;

use crate::core::num::Bool;
use crate::core::num::UnsignedInt;

use crate::core::device::DeviceNumber;
use crate::core::device::Id;
use crate::core::device::Label;
use crate::core::device::Name;
use crate::core::device::Offset;
use crate::core::device::Size;
use crate::core::device::TagName;
use crate::core::device::Usage;
use crate::core::device::Uuid;

use crate::core::partition::Endian;
use crate::core::partition::FileSystem;
use crate::core::partition::PartitionBitflags;
use crate::core::partition::PartitionTableType;
use crate::core::partition::PartitionType;
use crate::core::partition::RawBytes;
use crate::core::partition::UnixTimestamp;

/// A device tag.
///
/// # Examples
///
/// ```
/// # use pretty_assertions::assert_eq;
/// use rsblkid::core::device::Tag;
///
/// fn main() -> rsblkid::Result<()> {
///
///     // Parsing a LABEL.
///     let label_tag: Tag = "LABEL=nixos".parse()?;
///     let actual = matches!(label_tag, Tag::Label(_));
///     let expected = true;
///     assert_eq!(actual, expected);
///
///     // Parsing a UUID.
///     let uuid_tag: Tag = r#"UUID="ac4f36bf-191b-4fb0-b808-6d7fc9fc88be""#.parse()?;
///     let actual = matches!(uuid_tag, Tag::Uuid(_));
///     let expected = true;
///     assert_eq!(actual, expected);
///
///     Ok(())
/// }
/// ```
#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[non_exhaustive]
pub enum Tag {
    // Device Identifier
    // -------------------------------------------------------------------------
    /// Human readable filesystem identifier.
    Label(RawBytes),

    /// Filesystem universally unique identifier (UUID).
    Uuid(RawBytes),

    /// Human readable partition identifier.
    PartLabel(Label),

    /// Partition UUID.
    PartUuid(Uuid),

    /// Hardware block device ID as generated by `udevd`.
    Id(Id),
    // -------------------------------------------------------------------------

    // Partition Table / Partition Table Entry
    // -------------------------------------------------------------------------
    /// Partition table identifier (`UUID` for `GPT`, hexadecimal for `DOS` partition tables).
    PtUuid(Uuid),

    /// Partition table type (i.e. `dos`, `gpt`, etc.).
    PtType(PartitionTableType),

    /// Partition table signature, to identify a partition table header.
    // From UEFI specs
    // MBR: 0xAA55, GPT: ascii string 'EFI PART' encoded as the 64-bit constant 0x5452415020494645.
    PtMagic(RawBytes), // unsigned char * in libblkid -> Vec<u8> in rsblkid

    /// Location of the signature field in a partition table header.
    PtMagicOffset(Offset), // u64

    /// Partition type, either:
    /// - `OSType` a numerical code 0xNN (e.g. `0x82` Solaris x86, for more see the [List of
    /// partition identifiers for PCs](https://www.win.tue.nl/~aeb/partitions/partition_types-1.html)),
    /// - or a `UUID` that defines the purpose and type of a partition (used by `GPT` and `mac`
    /// partition entries).
    // From UEFI specs
    // length: MBR 1 byte, GPT 16 bytes
    PartEntryType(PartitionType),

    /// Partition number.
    PartEntryNumber(UnsignedInt), // int in libblkid -> u32 in rsblkid
    //
    /// Partition UUID (for `GPT`, or pseudo IDs for `MBR`).
    PartEntryUuid(Uuid),

    /// Location of the first 512-byte sector of a partition.
    PartEntryOffset(Offset), // u64

    /// Size of a partition in 512-byte sectors.
    PartEntrySize(Size), // u64

    /// Type of the partition table a partition entry is in.
    PartEntryScheme(PartitionTableType),

    /// Device number of the disk holding a partition.
    PartEntryDisk(DeviceNumber), // u64

    // From UEFI specs
    /// Partition flags:
    /// - BootIndicator field in [legacy MBR partition
    /// record](https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html#legacy-master-boot-record-mbr),
    /// or [Protective MBR partition
    /// record](https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html#protective-mbr)
    /// - Attribute bits, all bits reserved by UEFI; field in [GPT partition
    /// entry](https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html#gpt-partition-entry-array)
    // length: MBR 1 byte, GPT 8 bytes
    PartEntryFlags(PartitionBitflags),

    /// Null-terminated string containing a human-readable name of the partition, exclusively for
    /// `GPT` and `mac` partitions.
    PartEntryName(Name), // max length: 128 bytes unsigned char in libblkid
    // -------------------------------------------------------------------------

    // Device Topology
    // -------------------------------------------------------------------------
    /// Indicates how many bytes the beginning of the device is offset from the disk's natural
    /// alignment.
    AlignmentOffset(Offset), // u64

    /// The smallest unit a storage device can address, typically 512 bytes.
    LogicalSectorSize(Size), // u64

    /// The smallest unit a physical storage device can write atomically. It is usually the same as
    /// the logical sector size but may be larger.
    PhysicalSectorSize(Size), // u64

    /// A device's preferred unit of I/O in bytes.  For RAID arrays it is often the stripe chunk size.
    MinimumIoSize(Size), // u64

    /// A device's optimal unit of I/O in bytes, usually the stripe width for `RAID` or zero. For
    /// `RAID` arrays it is usually the stripe width, or the internal track size.
    OptimalIoSize(Size), // u64
    // -------------------------------------------------------------------------

    // ISO 9660/ ECMA 119
    // -------------------------------------------------------------------------
    // https://ecma-international.org/wp-content/uploads/ECMA-119_3rd_edition_december_2017.pdf
    // page 24
    /// ISO9660 application identifier.
    ApplicationId(Id),

    /// ISO9660 boot system identifier.
    BootSystemId(Id),

    /// ISO9660 data identifier.
    DataPreparerId(Id),

    /// ISO9660 publisher identifier.
    PublisherId(Id),

    /// ISO9660 system identifier.
    SystemId(Id),

    /// ISO9660 volume set identifier.
    VolumeSetId(Id),

    /// ISO9660 volume identifier.
    VolumeId(Id),
    // -------------------------------------------------------------------------

    // File System
    // -------------------------------------------------------------------------
    /// File system type.
    Type(FileSystem),

    /// Secondary file system type.
    SecType(FileSystem),

    /// Order in which bytes within a word are addressed in a file system.
    Endianness(Endian), // 'BIG' or 'LITTLE'

    /// Signature to identify the type of a file system.
    SbMagic(RawBytes), // unsigned char* -> Vec<u8>

    /// Location of a file system's signature.
    SbMagicOffset(Offset), // u64

    /// Accepts file systems with bad superblock checksums.
    SbBadChecksum(Bool),

    /// File system version.
    Version(Name),

    /// Minimal block size accessible by a file system.
    BlockSize(Size),

    /// Size in bytes of a file system block.
    FsBlockSize(Size), // u32

    /// File system size in bytes.
    FsSize(Size), // u64

    /// Last file system block/number of file system blocks.
    FsLastBlock(Offset), // u64

    /// Device usage.
    Usage(Usage),

    /// Raw label from a file system superblock.
    LabelRaw(RawBytes),

    /// File system raw UUID.
    UuidRaw(RawBytes),

    /// UUID of an external journal for file systems that keep track of changes, not yet committed
    /// in a journal, on a separate physical device.
    ExtJournal(Uuid),

    /// Subvolume UUID (e.g. `BTRFS`).
    UuidSub(RawBytes),

    /// External log UUID (e.g. `XFS`).
    LogUuid(Uuid),

    /// Cluster mount name (OCFS only).
    Mount(Name),

    /// VFAT boot sector OEM label.
    LabelFatboot(RawBytes),

    // From
    // https://ecma-international.org/wp-content/uploads/ECMA-167_3rd_edition_june_1997.pdf
    // Section 9 - Volume recognition structures
    /// Universal Disk Format (UDF) volume identifier ( used for DVDs and newer optical disc
    /// formats). FIXME is this correct?
    LogicalVolumeId(Id),

    /// Linux Unified Key Setup (LUKS) owner subsystem label.
    SubSystem(Label),

    // From Signature Block table in
    // https://stratis-storage.github.io/StratisSoftwareDesign.pdf
    // page 16
    /// Initialization time of a Stratis Signature Block (UNIX timestamp, seconds since January, 1
    /// 1970 (u64)).
    BlockdevInitTime(UnixTimestamp), // u64

    /// Stratis device size in 512-byte sectors.
    BlockdevSectors(Size), // u64

    /// Stratis pool UUID. FIXME is this correct?
    PoolUuid(Uuid),
}

impl Tag {
    /// Returns a `Tag`'s name.
    pub fn name(&self) -> TagName {
        TagName::from(self)
    }

    /// Returns a `Tag`'s value.
    pub fn value(&self) -> &str {
        match self {
            Self::Label(value) => value.as_str_safe(),
            Self::Uuid(value) => value.as_str_safe(),
            Self::PartLabel(value) => value.as_str(),
            Self::PartUuid(value) => value.as_str(),
            Self::Id(value) => value.as_str(),
            Self::PtUuid(value) => value.as_str(),
            Self::PtType(value) => value.as_str(),
            Self::PtMagic(value) => value.as_str_safe(),
            Self::PtMagicOffset(value) => value.as_str(),
            Self::PartEntryType(value) => value.as_str(),
            Self::PartEntryNumber(value) => value.as_str(),
            Self::PartEntryUuid(value) => value.as_str(),
            Self::PartEntryOffset(value) => value.as_str(),
            Self::PartEntrySize(value) => value.as_str(),
            Self::PartEntryScheme(value) => value.as_str(),
            Self::PartEntryDisk(value) => value.as_str(),
            Self::PartEntryFlags(value) => value.as_str(),
            Self::PartEntryName(value) => value.as_str(),
            Self::AlignmentOffset(value) => value.as_str(),
            Self::LogicalSectorSize(value) => value.as_str(),
            Self::PhysicalSectorSize(value) => value.as_str(),
            Self::MinimumIoSize(value) => value.as_str(),
            Self::OptimalIoSize(value) => value.as_str(),
            Self::ApplicationId(value) => value.as_str(),
            Self::BootSystemId(value) => value.as_str(),
            Self::DataPreparerId(value) => value.as_str(),
            Self::PublisherId(value) => value.as_str(),
            Self::SystemId(value) => value.as_str(),
            Self::VolumeSetId(value) => value.as_str(),
            Self::VolumeId(value) => value.as_str(),
            Self::Type(value) => value.as_str(),
            Self::SecType(value) => value.as_str(),
            Self::Endianness(value) => value.as_str(),
            Self::SbMagic(value) => value.as_str_safe(),
            Self::SbMagicOffset(value) => value.as_str(),
            Self::SbBadChecksum(value) => value.as_str(),
            Self::Version(value) => value.as_str(),
            Self::BlockSize(value) => value.as_str(),
            Self::FsBlockSize(value) => value.as_str(),
            Self::FsSize(value) => value.as_str(),
            Self::FsLastBlock(value) => value.as_str(),
            Self::Usage(value) => value.as_str(),
            Self::LabelRaw(value) => value.as_str_safe(),
            Self::UuidRaw(value) => value.as_str_safe(),
            Self::ExtJournal(value) => value.as_str(),
            Self::UuidSub(value) => value.as_str_safe(),
            Self::LogUuid(value) => value.as_str(),
            Self::Mount(value) => value.as_str(),
            Self::LabelFatboot(value) => value.as_str_safe(),
            Self::LogicalVolumeId(value) => value.as_str(),
            Self::SubSystem(value) => value.as_str(),
            Self::BlockdevInitTime(value) => value.as_str(),
            Self::BlockdevSectors(value) => value.as_str(),
            Self::PoolUuid(value) => value.as_str(),
        }
    }

    /// Converts this `Tag`'s value to a [`CString`].
    pub fn value_to_c_string(&self) -> Result<CString, NulError> {
        CString::new(self.value())
    }

    /// Converts this `Tag` to a [`CString`].
    pub fn to_c_string(&self) -> Result<CString, NulError> {
        CString::new(self.to_string())
    }

    /// Converts a `Tag` to a udev-compatible [`String`]
    /// (for more information, see the function
    /// [`print_udev_format`](https://github.com/util-linux/util-linux/blob/stable/v2.39/misc-utils/blkid.c#L253)
    /// from `libblkid`).
    pub fn to_udev_format(&self) -> Result<String, EncodeError> {
        let output = match self {
            Self::Label(value)
            | Self::LabelFatboot(value)
            | Self::Uuid(value)
            | Self::UuidSub(value) => {
                let encoded_value = encode_string(value.as_bytes())?;
                let safe_value = value.as_str_safe();

                format!(
                    "ID_FS_{}={}\nID_FS_{0}_ENC={}",
                    self.name(),
                    safe_value,
                    encoded_value
                )
            }
            Self::PtUuid(_) => {
                let encoded_value = encode_string(self.value().as_bytes())?;

                format!("ID_PART_TABLE_UUID={}", encoded_value)
            }
            Self::PtType(_) => {
                let encoded_value = encode_string(self.value().as_bytes())?;

                format!("ID_PART_TABLE_TYPE={}", encoded_value)
            }
            Self::PartEntryType(_)
            | Self::PartEntryNumber(_)
            | Self::PartEntryUuid(_)
            | Self::PartEntryOffset(_)
            | Self::PartEntrySize(_)
            | Self::PartEntryScheme(_)
            | Self::PartEntryDisk(_)
            | Self::PartEntryFlags(_)
            | Self::PartEntryName(_) => {
                let encoded_value = encode_string(self.value().as_bytes())?;

                format!("ID_{}={}", self.name(), encoded_value)
            }
            Self::AlignmentOffset(_)
            | Self::LogicalSectorSize(_)
            | Self::PhysicalSectorSize(_)
            | Self::MinimumIoSize(_)
            | Self::OptimalIoSize(_) => {
                let encoded_value = encode_string(self.value().as_bytes())?;

                format!("ID_IOLIMIT_{}={}", self.name(), encoded_value)
            }
            Self::PtMagic(value)
            | Self::SbMagic(value)
            | Self::LabelRaw(value)
            | Self::UuidRaw(value) => {
                let encoded_value = encode_string(value.as_bytes())?;

                format!("ID_FS_{}={}", self.name(), encoded_value)
            }
            _ => {
                let encoded_value = encode_string(self.value().as_bytes())?;

                format!("ID_FS_{}={}", self.name(), encoded_value)
            }
        };

        Ok(output)
    }
}

impl fmt::Display for Tag {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, r#"{}="{}""#, self.name(), self.value())
    }
}

impl AsRef<Tag> for Tag {
    #[inline]
    fn as_ref(&self) -> &Tag {
        self
    }
}

impl<T> TryFrom<(TagName, T)> for Tag
where
    T: AsRef<[u8]>,
{
    type Error = ConversionError;

    fn try_from(pair: (TagName, T)) -> Result<Self, Self::Error> {
        let (tag_name, value) = pair;
        let value = value.as_ref();

        match tag_name {
            TagName::Label => Ok(Self::Label(RawBytes::from(value))),
            TagName::Uuid => Ok(Self::Uuid(RawBytes::from(value))),
            TagName::PartLabel => Label::try_from(value).map(Self::PartLabel),
            TagName::PartUuid => Uuid::try_from(value).map(Self::PartUuid),
            TagName::Id => Id::try_from(value).map(Self::Id),
            TagName::PtUuid => Uuid::try_from(value).map(Self::PtUuid),
            TagName::PtType => PartitionTableType::try_from(value).map(Self::PtType),
            TagName::PtMagic => Ok(Self::PtMagic(RawBytes::from(value))),
            TagName::PtMagicOffset => Offset::try_from_u64(value).map(Self::PtMagicOffset),
            TagName::PartEntryType => PartitionType::try_from(value).map(Self::PartEntryType),
            TagName::PartEntryNumber => UnsignedInt::try_from_u32(value).map(Self::PartEntryNumber),
            TagName::PartEntryUuid => Uuid::try_from(value).map(Self::PartEntryUuid),
            TagName::PartEntryOffset => Offset::try_from_u64(value).map(Self::PartEntryOffset),
            TagName::PartEntrySize => Size::try_from_u64(value).map(Self::PartEntrySize),
            TagName::PartEntryScheme => {
                PartitionTableType::try_from(value).map(Self::PartEntryScheme)
            }
            TagName::PartEntryDisk => DeviceNumber::try_from(value).map(Self::PartEntryDisk),
            TagName::PartEntryFlags => PartitionBitflags::try_from(value).map(Self::PartEntryFlags),
            TagName::PartEntryName => Name::try_from(value).map(Self::PartEntryName),
            TagName::AlignmentOffset => Offset::try_from_u64(value).map(Self::AlignmentOffset),
            TagName::LogicalSectorSize => Size::try_from_u64(value).map(Self::LogicalSectorSize),
            TagName::PhysicalSectorSize => Size::try_from_u64(value).map(Self::PhysicalSectorSize),
            TagName::MinimumIoSize => Size::try_from_u64(value).map(Self::MinimumIoSize),
            TagName::OptimalIoSize => Size::try_from_u64(value).map(Self::OptimalIoSize),
            TagName::ApplicationId => Id::try_from(value).map(Self::ApplicationId),
            TagName::BootSystemId => Id::try_from(value).map(Self::BootSystemId),
            TagName::DataPreparerId => Id::try_from(value).map(Self::DataPreparerId),
            TagName::PublisherId => Id::try_from(value).map(Self::PublisherId),
            TagName::SystemId => Id::try_from(value).map(Self::SystemId),
            TagName::VolumeSetId => Id::try_from(value).map(Self::VolumeSetId),
            TagName::VolumeId => Id::try_from(value).map(Self::VolumeId),
            TagName::Type => FileSystem::try_from(value).map(Self::Type),
            TagName::SecType => FileSystem::try_from(value).map(Self::SecType),
            TagName::Endianness => Endian::try_from(value).map(Self::Endianness),
            TagName::SbMagic => Ok(Self::SbMagic(RawBytes::from(value))),
            TagName::SbMagicOffset => Offset::try_from_u64(value).map(Self::SbMagicOffset),
            TagName::SbBadChecksum => Bool::try_from(value).map(Self::SbBadChecksum),
            TagName::Version => Name::try_from(value).map(Self::Version),
            TagName::BlockSize => Size::try_from_u32(value).map(Self::BlockSize),
            TagName::FsBlockSize => Size::try_from_u32(value).map(Self::FsBlockSize),
            TagName::FsSize => Size::try_from_u64(value).map(Self::FsSize),
            TagName::FsLastBlock => Offset::try_from_u64(value).map(Self::FsLastBlock),
            TagName::Usage => Usage::try_from(value).map(Self::Usage),
            TagName::LabelRaw => Ok(Self::LabelRaw(RawBytes::from(value))),
            TagName::UuidRaw => Ok(Self::UuidRaw(RawBytes::from(value))),
            TagName::ExtJournal => Uuid::try_from(value).map(Self::ExtJournal),
            TagName::UuidSub => Ok(Self::UuidSub(RawBytes::from(value))),
            TagName::LogUuid => Uuid::try_from(value).map(Self::LogUuid),
            TagName::Mount => Name::try_from(value).map(Self::Mount),
            TagName::LabelFatboot => Ok(Self::LabelFatboot(RawBytes::from(value))),
            TagName::LogicalVolumeId => Id::try_from(value).map(Self::LogicalVolumeId),
            TagName::SubSystem => Label::try_from(value).map(Self::SubSystem),
            TagName::BlockdevInitTime => UnixTimestamp::try_from(value).map(Self::BlockdevInitTime),
            TagName::BlockdevSectors => Size::try_from_u64(value).map(Self::BlockdevSectors),
            TagName::PoolUuid => Uuid::try_from(value).map(Self::PoolUuid),
        }
    }
}

impl FromStr for Tag {
    type Err = ParserError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let err_msg = format!("invalid tag: {:?}. Missing `=` sign", s);
        let (tag_name, value) = s.split_once('=').ok_or(ParserError::Tag(err_msg))?;

        let tag_name = TagName::from_str(tag_name)?;
        match tag_name {
            TagName::Label => RawBytes::from_str(value).map(Self::Label),
            TagName::Uuid => RawBytes::from_str(value).map(Self::Uuid),
            TagName::PartLabel => Label::from_str(value).map(Self::PartLabel),
            TagName::PartUuid => Uuid::from_str(value).map(Self::PartUuid),
            TagName::Id => Id::from_str(value).map(Self::Id),
            TagName::PtUuid => Uuid::from_str(value).map(Self::PtUuid),
            TagName::PtType => PartitionTableType::from_str(value).map(Self::PtType),
            TagName::PtMagic => RawBytes::from_str(value).map(Self::PtMagic),
            TagName::PtMagicOffset => Offset::from_str_u64(value).map(Self::PtMagicOffset),
            TagName::PartEntryType => PartitionType::from_str(value).map(Self::PartEntryType),
            TagName::PartEntryNumber => UnsignedInt::from_str_u32(value).map(Self::PartEntryNumber),
            TagName::PartEntryUuid => Uuid::from_str(value).map(Self::PartEntryUuid),
            TagName::PartEntryOffset => Offset::from_str_u64(value).map(Self::PartEntryOffset),
            TagName::PartEntrySize => Size::from_str_u64(value).map(Self::PartEntrySize),
            TagName::PartEntryScheme => {
                PartitionTableType::from_str(value).map(Self::PartEntryScheme)
            }
            TagName::PartEntryDisk => DeviceNumber::from_str(value).map(Self::PartEntryDisk),
            TagName::PartEntryFlags => PartitionBitflags::from_str(value).map(Self::PartEntryFlags),
            TagName::PartEntryName => Name::from_str(value).map(Self::PartEntryName),
            TagName::AlignmentOffset => Offset::from_str_u64(value).map(Self::AlignmentOffset),
            TagName::LogicalSectorSize => Size::from_str_u64(value).map(Self::LogicalSectorSize),
            TagName::PhysicalSectorSize => Size::from_str_u64(value).map(Self::PhysicalSectorSize),
            TagName::MinimumIoSize => Size::from_str_u64(value).map(Self::MinimumIoSize),
            TagName::OptimalIoSize => Size::from_str_u64(value).map(Self::OptimalIoSize),
            TagName::ApplicationId => Id::from_str(value).map(Self::ApplicationId),
            TagName::BootSystemId => Id::from_str(value).map(Self::BootSystemId),
            TagName::DataPreparerId => Id::from_str(value).map(Self::DataPreparerId),
            TagName::PublisherId => Id::from_str(value).map(Self::PublisherId),
            TagName::SystemId => Id::from_str(value).map(Self::SystemId),
            TagName::VolumeSetId => Id::from_str(value).map(Self::VolumeSetId),
            TagName::VolumeId => Id::from_str(value).map(Self::VolumeId),
            TagName::Type => FileSystem::from_str(value).map(Self::Type),
            TagName::SecType => FileSystem::from_str(value).map(Self::SecType),
            TagName::Endianness => Endian::from_str(value).map(Self::Endianness),
            TagName::SbMagic => RawBytes::from_str(value).map(Self::SbMagic),
            TagName::SbMagicOffset => Offset::from_str_u64(value).map(Self::SbMagicOffset),
            TagName::SbBadChecksum => Bool::from_str(value).map(Self::SbBadChecksum),
            TagName::Version => Name::from_str(value).map(Self::Version),
            TagName::BlockSize => Size::from_str_u32(value).map(Self::BlockSize),
            TagName::FsBlockSize => Size::from_str_u32(value).map(Self::FsBlockSize),
            TagName::FsSize => Size::from_str_u64(value).map(Self::FsSize),
            TagName::FsLastBlock => Offset::from_str_u64(value).map(Self::FsLastBlock),
            TagName::Usage => Usage::from_str(value).map(Self::Usage),
            TagName::LabelRaw => RawBytes::from_str(value).map(Self::LabelRaw),
            TagName::UuidRaw => RawBytes::from_str(value).map(Self::UuidRaw),
            TagName::ExtJournal => Uuid::from_str(value).map(Self::ExtJournal),
            TagName::UuidSub => RawBytes::from_str(value).map(Self::UuidSub),
            TagName::LogUuid => Uuid::from_str(value).map(Self::LogUuid),
            TagName::Mount => Name::from_str(value).map(Self::Mount),
            TagName::LabelFatboot => RawBytes::from_str(value).map(Self::LabelFatboot),
            TagName::LogicalVolumeId => Id::from_str(value).map(Self::LogicalVolumeId),
            TagName::SubSystem => Label::from_str(value).map(Self::SubSystem),
            TagName::BlockdevInitTime => UnixTimestamp::from_str(value).map(Self::BlockdevInitTime),
            TagName::BlockdevSectors => Size::from_str_u64(value).map(Self::BlockdevSectors),
            TagName::PoolUuid => Uuid::from_str(value).map(Self::PoolUuid),
        }
    }
}
