// Copyright (c) 2023 Nick Piaddo
// SPDX-License-Identifier: Apache-2.0 OR MIT

// From dependency library

// From standard library
use std::ffi::{CStr, CString};
use std::fmt;
use std::str::FromStr;

// From this library
use crate::core::errors::ConversionError;
use crate::core::errors::ParserError;

use crate::core::device::Tag;

/// Tag names supported by `libmount`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[non_exhaustive]
pub enum TagName {
    // Device Identifier
    // -------------------------------------------------------------------------
    /// Human readable file system identifier.
    Label,

    /// File system universally unique identifier (lower case).
    Uuid,

    /// Human readable partition identifier.
    PartLabel,

    /// Partition UUID.
    PartUuid,

    /// Hardware block device ID as generated by `udevd`.
    Id,
    // -------------------------------------------------------------------------

    // Partition Table / Partition Table Entry
    // -------------------------------------------------------------------------
    /// Partition table identifier (`UUID` for `GPT`, hexadecimal for `DOS` partition tables).
    PtUuid,

    /// Partition table type (i.e. `dos`, `gpt`, etc.).
    PtType,

    /// Partition table signature, to identify a partition table header.
    // From UEFI specs
    // MBR: 0xAA55, GPT: ascii string 'EFI PART' encoded as the 64-bit constant 0x5452415020494645.
    PtMagic, // unsigned char * in libblkid -> Vec<u8> in rsblkid

    /// Location of the signature field in a partition table header.
    PtMagicOffset, // u64

    /// Partition type, either:
    /// - `OSType` a numerical code 0xNN (e.g. `0x82` Solaris x86, for more see the [List of
    /// partition identifiers for PCs](https://www.win.tue.nl/~aeb/partitions/partition_types-1.html)),
    /// - or a `UUID` that defines the purpose and type of a partition (used by `GPT` and `mac`
    /// partition entries).
    // From UEFI specs
    // length: MBR 1 byte, GPT 16 bytes
    PartEntryType,

    /// Partition number.
    PartEntryNumber, // int in libblkid -> u32 in rsblkid

    /// Partition UUID (for `GPT`, or pseudo IDs for `MBR`).
    PartEntryUuid,

    /// Location of the first 512-byte sector of a partition.
    PartEntryOffset, // u64

    /// Size of a partition in 512-byte sectors.
    PartEntrySize, // u64

    /// Type of the partition table a partition entry is in.
    PartEntryScheme,

    /// Device number of the disk holding a partition.
    PartEntryDisk, // u64

    // From UEFI specs
    /// Partition flags:
    /// - BootIndicator field in [legacy MBR partition
    /// record](https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html#legacy-master-boot-record-mbr),
    /// or [Protective MBR partition
    /// record](https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html#protective-mbr)
    /// - Attribute bits, all bits reserved by UEFI; field in [GPT partition
    /// entry](https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html#gpt-partition-entry-array)
    // length: MBR 1 byte, GPT 8 bytes
    PartEntryFlags,

    /// Null-terminated string containing a human-readable name of the partition, exclusively for
    /// `GPT` and `mac` partitions.
    PartEntryName, // max length: 128 bytes unsigned char in libblkid
    // -------------------------------------------------------------------------

    // Device Topology
    // -------------------------------------------------------------------------
    /// Indicates how many bytes the beginning of the device is offset from the disk's natural
    /// alignment.
    AlignmentOffset, // u64

    /// The smallest unit a storage device can address, typically 512 bytes.
    LogicalSectorSize, // u64

    /// The smallest unit a physical storage device can write atomically. It is usually the same as
    /// the logical sector size but may be larger.
    PhysicalSectorSize, // u64

    /// A device's preferred unit of I/O in bytes.  For RAID arrays it is often the stripe chunk size.
    MinimumIoSize, // u64

    /// A device's optimal unit of I/O in bytes, usually the stripe width for `RAID` or zero. For
    /// `RAID` arrays it is usually the stripe width, or the internal track size.
    OptimalIoSize, // u64
    // -------------------------------------------------------------------------

    // ISO 9660/ ECMA 119
    // -------------------------------------------------------------------------
    // https://ecma-international.org/wp-content/uploads/ECMA-119_3rd_edition_december_2017.pdf
    // page 24
    /// ISO9660 application identifier.
    ApplicationId,

    /// ISO9660 boot system identifier.
    BootSystemId,

    /// ISO9660 data identifier.
    DataPreparerId,

    /// ISO9660 publisher identifier.
    PublisherId,

    /// ISO9660 system identifier.
    SystemId,

    /// ISO9660 Volume Set Identifier.
    VolumeSetId,

    /// ISO9660 Volume Identifier.
    VolumeId,
    // -------------------------------------------------------------------------

    // File System
    // -------------------------------------------------------------------------
    /// File system type.
    Type,

    /// Secondary file system type.
    SecType,

    /// Order in which bytes within a word are addressed in a file system.
    Endianness, // 'BIG' or 'LITTLE'

    /// Signature to identify the type of a file system.
    SbMagic, // unsigned char* -> Vec<u8>

    /// Location of a file system's signature.
    SbMagicOffset, // u64

    /// Accepts file systems with bad superblock checksums.
    SbBadChecksum,

    /// File system version.
    Version,

    /// Minimal block size accessible by a file system.
    BlockSize, // u32

    /// Size in bytes of a file system block.
    FsBlockSize, // u32

    /// File system size in bytes.
    FsSize, // u64

    /// Last file system block/number of file system blocks.
    FsLastBlock, // u64

    /// Device usage.
    Usage, // `filesystem`,  `raid`, `crypto`, `other`

    /// Raw label from file system superblock.
    LabelRaw,

    /// File system raw UUID.
    UuidRaw,

    /// UUID of an external journal for file systems that keep track of changes, not yet committed
    /// in a journal, on a separate physical device.
    ExtJournal,

    /// Subvolume UUID (e.g. `BTRFS`).
    UuidSub,

    /// External log UUID (e.g. `XFS`).
    LogUuid,

    /// Cluster mount name (OCFS only).
    Mount,

    /// VFAT boot sector OEM label.
    LabelFatboot,

    // From
    // https://ecma-international.org/wp-content/uploads/ECMA-167_3rd_edition_june_1997.pdf
    // Section 9 - Volume recognition structures
    /// Universal Disk Format (UDF) volume identifier ( used for DVDs and newer optical disc
    /// formats). FIXME is this correct?
    LogicalVolumeId,

    /// Linux Unified Key Setup (LUKS) owner subsystem label.
    SubSystem,

    // From Signature Block table in
    // https://stratis-storage.github.io/StratisSoftwareDesign.pdf
    // page 16
    /// Initialization time of a Stratis signature block (UNIX timestamp, seconds since January, 1
    /// 1970 (u64)).
    BlockdevInitTime, // u64

    /// Stratis device size in 512-byte sectors.
    BlockdevSectors, // u64

    /// Stratis pool UUID. FIXME is this correct?
    PoolUuid,
}

impl TagName {
    /// View this `TagName` as a UTF-8 `str`.
    pub fn as_str(&self) -> &str {
        match self {
            Self::Label => "LABEL",
            Self::Uuid => "UUID",
            Self::PartLabel => "PARTLABEL",
            Self::PartUuid => "PARTUUID",
            Self::Id => "ID",
            Self::PtUuid => "PTUUID",
            Self::PtType => "PTTYPE",
            Self::PtMagic => "PTMAGIC",
            Self::PtMagicOffset => "PTMAGIC_OFFSET",
            Self::PartEntryType => "PART_ENTRY_TYPE",
            Self::PartEntryNumber => "PART_ENTRY_NUMBER",
            Self::PartEntryUuid => "PART_ENTRY_UUID",
            Self::PartEntryOffset => "PART_ENTRY_OFFSET",
            Self::PartEntrySize => "PART_ENTRY_SIZE",
            Self::PartEntryScheme => "PART_ENTRY_SCHEME",
            Self::PartEntryDisk => "PART_ENTRY_DISK",
            Self::PartEntryFlags => "PART_ENTRY_FLAGS",
            Self::PartEntryName => "PART_ENTRY_NAME",
            Self::AlignmentOffset => "ALIGNMENT_OFFSET",
            Self::LogicalSectorSize => "LOGICAL_SECTOR_SIZE",
            Self::PhysicalSectorSize => "PHYSICAL_SECTOR_SIZE",
            Self::MinimumIoSize => "MINIMUM_IO_SIZE",
            Self::OptimalIoSize => "OPTIMAL_IO_SIZE",
            Self::ApplicationId => "APPLICATION_ID",
            Self::BootSystemId => "BOOT_SYSTEM_ID",
            Self::DataPreparerId => "DATA_PREPARER_ID",
            Self::PublisherId => "PUBLISHER_ID",
            Self::SystemId => "SYSTEM_ID",
            Self::VolumeSetId => "VOLUME_SET_ID",
            Self::VolumeId => "VOLUME_ID",
            Self::Type => "TYPE",
            Self::SecType => "SEC_TYPE",
            Self::Endianness => "ENDIANNESS",
            Self::SbMagic => "SBMAGIC",
            Self::SbMagicOffset => "SBMAGIC_OFFSET",
            Self::SbBadChecksum => "SBBADCSUM",
            Self::Version => "VERSION",
            Self::BlockSize => "BLOCK_SIZE",
            Self::FsBlockSize => "FSBLOCKSIZE",
            Self::FsSize => "FSSIZE",
            Self::FsLastBlock => "FSLASTBLOCK",
            Self::Usage => "USAGE",
            Self::LabelRaw => "LABEL_RAW",
            Self::UuidRaw => "UUID_RAW",
            Self::ExtJournal => "EXT_JOURNAL",
            Self::UuidSub => "UUID_SUB",
            Self::LogUuid => "LOGUUID",
            Self::Mount => "MOUNT",
            Self::LabelFatboot => "LABEL_FATBOOT",
            Self::LogicalVolumeId => "LOGICAL_VOLUME_ID",
            Self::SubSystem => "SUBSYSTEM",
            Self::BlockdevInitTime => "BLOCKDEV_INITTIME",
            Self::BlockdevSectors => "BLOCKDEV_SECTORS",
            Self::PoolUuid => "POOL_UUID",
        }
    }

    /// Converts this `TagName` to a [`CString`].
    pub fn to_c_string(&self) -> CString {
        // TagName's string representation does not contain NULL characters,  we can safely
        // unwrap the new CString.
        CString::new(self.as_str()).unwrap()
    }

    /// Converts this `TagName` to a byte slice.
    pub fn as_bytes(&self) -> &[u8] {
        self.as_str().as_bytes()
    }
}

impl AsRef<TagName> for TagName {
    #[inline]
    fn as_ref(&self) -> &TagName {
        self
    }
}

impl AsRef<str> for TagName {
    #[inline]
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl fmt::Display for TagName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl TryFrom<&[u8]> for TagName {
    type Error = ConversionError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        std::str::from_utf8(bytes)
            .map_err(|e| {
                ConversionError::TagName(format!(
                    "bytes to UTF-8 string slice conversion error. {:?}",
                    e
                ))
            })
            .and_then(|s| Self::from_str(s).map_err(|e| ConversionError::TagName(e.to_string())))
    }
}

impl TryFrom<Vec<u8>> for TagName {
    type Error = ConversionError;

    #[inline]
    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {
        Self::try_from(bytes.as_slice())
    }
}

impl TryFrom<&CStr> for TagName {
    type Error = ConversionError;

    fn try_from(s: &CStr) -> Result<Self, Self::Error> {
        s.to_str()
            .map_err(|e| {
                ConversionError::CStr(format!(
                    "CStr {:?} to UTF-8 string slice conversion error. {:?}",
                    s, e
                ))
            })
            .and_then(|s| Self::from_str(s).map_err(|e| ConversionError::TagName(e.to_string())))
    }
}

impl TryFrom<CString> for TagName {
    type Error = ConversionError;

    #[inline]
    fn try_from(s: CString) -> Result<Self, Self::Error> {
        Self::try_from(s.as_c_str())
    }
}

impl FromStr for TagName {
    type Err = ParserError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.trim().to_uppercase().as_str() {
            "LABEL" => Ok(Self::Label),
            "UUID" => Ok(Self::Uuid),
            "PARTLABEL" => Ok(Self::PartLabel),
            "PARTUUID" => Ok(Self::PartUuid),
            "ID" => Ok(Self::Id),
            "PTUUID" => Ok(Self::PtUuid),
            "PTTYPE" => Ok(Self::PtType),
            "PTMAGIC" => Ok(Self::PtMagic),
            "PTMAGIC_OFFSET" => Ok(Self::PtMagicOffset),
            "PART_ENTRY_TYPE" => Ok(Self::PartEntryType),
            "PART_ENTRY_NUMBER" => Ok(Self::PartEntryNumber),
            "PART_ENTRY_UUID" => Ok(Self::PartEntryUuid),
            "PART_ENTRY_OFFSET" => Ok(Self::PartEntryOffset),
            "PART_ENTRY_SIZE" => Ok(Self::PartEntrySize),
            "PART_ENTRY_SCHEME" => Ok(Self::PartEntryScheme),
            "PART_ENTRY_DISK" => Ok(Self::PartEntryDisk),
            "PART_ENTRY_FLAGS" => Ok(Self::PartEntryFlags),
            "PART_ENTRY_NAME" => Ok(Self::PartEntryName),
            "ALIGNMENT_OFFSET" => Ok(Self::AlignmentOffset),
            "LOGICAL_SECTOR_SIZE" => Ok(Self::LogicalSectorSize),
            "PHYSICAL_SECTOR_SIZE" => Ok(Self::PhysicalSectorSize),
            "MINIMUM_IO_SIZE" => Ok(Self::MinimumIoSize),
            "OPTIMAL_IO_SIZE" => Ok(Self::OptimalIoSize),
            "APPLICATION_ID" => Ok(Self::ApplicationId),
            "BOOT_SYSTEM_ID" => Ok(Self::BootSystemId),
            "DATA_PREPARER_ID" => Ok(Self::DataPreparerId),
            "PUBLISHER_ID" => Ok(Self::PublisherId),
            "SYSTEM_ID" => Ok(Self::SystemId),
            "VOLUME_SET_ID" => Ok(Self::VolumeSetId),
            "VOLUME_ID" => Ok(Self::VolumeId),
            "TYPE" => Ok(Self::Type),
            "SEC_TYPE" => Ok(Self::SecType),
            "ENDIANNESS" => Ok(Self::Endianness),
            "SBMAGIC" => Ok(Self::SbMagic),
            "SBMAGIC_OFFSET" => Ok(Self::SbMagicOffset),
            "SBBADCSUM" => Ok(Self::SbBadChecksum),
            "VERSION" => Ok(Self::Version),
            "BLOCK_SIZE" => Ok(Self::BlockSize),
            "FSBLOCKSIZE" => Ok(Self::FsBlockSize),
            "FSSIZE" => Ok(Self::FsSize),
            "FSLASTBLOCK" => Ok(Self::FsLastBlock),
            "USAGE" => Ok(Self::Usage),
            "LABEL_RAW" => Ok(Self::LabelRaw),
            "UUID_RAW" => Ok(Self::UuidRaw),
            "EXT_JOURNAL" => Ok(Self::ExtJournal),
            "UUID_SUB" => Ok(Self::UuidSub),
            "LOGUUID" => Ok(Self::LogUuid),
            "MOUNT" => Ok(Self::Mount),
            "LABEL_FATBOOT" => Ok(Self::LabelFatboot),
            "LOGICAL_VOLUME_ID" => Ok(Self::LogicalVolumeId),
            "SUBSYSTEM" => Ok(Self::SubSystem),
            "BLOCKDEV_INITTIME" => Ok(Self::BlockdevInitTime),
            "BLOCKDEV_SECTORS" => Ok(Self::BlockdevSectors),
            "POOL_UUID" => Ok(Self::PoolUuid),
            _otherwise => {
                let err_msg = format!("invalid tag name: {:?}", s);

                Err(ParserError::TagName(err_msg))
            }
        }
    }
}

impl<T> From<T> for TagName
where
    T: AsRef<Tag>,
{
    fn from(tag: T) -> TagName {
        match tag.as_ref() {
            Tag::Label(_) => Self::Label,
            Tag::Uuid(_) => Self::Uuid,
            Tag::PartLabel(_) => Self::PartLabel,
            Tag::PartUuid(_) => Self::PartUuid,
            Tag::Id(_) => Self::Id,
            Tag::PtUuid(_) => Self::PtUuid,
            Tag::PtType(_) => Self::PtType,
            Tag::PtMagic(_) => Self::PtMagic,
            Tag::PtMagicOffset(_) => Self::PtMagicOffset,
            Tag::PartEntryType(_) => Self::PartEntryType,
            Tag::PartEntryNumber(_) => Self::PartEntryNumber,
            Tag::PartEntryUuid(_) => Self::PartEntryUuid,
            Tag::PartEntryOffset(_) => Self::PartEntryOffset,
            Tag::PartEntrySize(_) => Self::PartEntrySize,
            Tag::PartEntryScheme(_) => Self::PartEntryScheme,
            Tag::PartEntryDisk(_) => Self::PartEntryDisk,
            Tag::PartEntryFlags(_) => Self::PartEntryFlags,
            Tag::PartEntryName(_) => Self::PartEntryName,
            Tag::AlignmentOffset(_) => Self::AlignmentOffset,
            Tag::LogicalSectorSize(_) => Self::LogicalSectorSize,
            Tag::PhysicalSectorSize(_) => Self::PhysicalSectorSize,
            Tag::MinimumIoSize(_) => Self::MinimumIoSize,
            Tag::OptimalIoSize(_) => Self::OptimalIoSize,
            Tag::ApplicationId(_) => Self::ApplicationId,
            Tag::BootSystemId(_) => Self::BootSystemId,
            Tag::DataPreparerId(_) => Self::DataPreparerId,
            Tag::PublisherId(_) => Self::PublisherId,
            Tag::SystemId(_) => Self::SystemId,
            Tag::VolumeSetId(_) => Self::VolumeSetId,
            Tag::VolumeId(_) => Self::VolumeId,
            Tag::Type(_) => Self::Type,
            Tag::SecType(_) => Self::SecType,
            Tag::Endianness(_) => Self::Endianness,
            Tag::SbMagic(_) => Self::SbMagic,
            Tag::SbMagicOffset(_) => Self::SbMagicOffset,
            Tag::SbBadChecksum(_) => Self::SbBadChecksum,
            Tag::Version(_) => Self::Version,
            Tag::BlockSize(_) => Self::BlockSize,
            Tag::FsBlockSize(_) => Self::FsBlockSize,
            Tag::FsSize(_) => Self::FsSize,
            Tag::FsLastBlock(_) => Self::FsLastBlock,
            Tag::Usage(_) => Self::Usage,
            Tag::LabelRaw(_) => Self::LabelRaw,
            Tag::UuidRaw(_) => Self::UuidRaw,
            Tag::ExtJournal(_) => Self::ExtJournal,
            Tag::UuidSub(_) => Self::UuidSub,
            Tag::LogUuid(_) => Self::LogUuid,
            Tag::Mount(_) => Self::Mount,
            Tag::LabelFatboot(_) => Self::LabelFatboot,
            Tag::LogicalVolumeId(_) => Self::LogicalVolumeId,
            Tag::SubSystem(_) => Self::SubSystem,
            Tag::BlockdevInitTime(_) => Self::BlockdevInitTime,
            Tag::BlockdevSectors(_) => Self::BlockdevSectors,
            Tag::PoolUuid(_) => Self::PoolUuid,
        }
    }
}

#[cfg(test)]
#[allow(unused_imports)]
mod tests {
    use super::*;
    use pretty_assertions::{assert_eq, assert_ne};

    #[test]
    #[should_panic(expected = "invalid tag name")]
    fn tag_name_can_not_parse_empty_string() {
        let _: TagName = "".parse().unwrap();
    }

    #[test]
    #[should_panic(expected = "invalid tag name")]
    fn tag_name_can_not_parse_invalid_string() {
        let _: TagName = "DUMMY".parse().unwrap();
    }

    #[test]
    #[should_panic(expected = "bytes to UTF-8 string slice conversion error")]
    fn tag_name_can_not_convert_invalid_bytes_into_a_tag_name() {
        // some invalid bytes, in a vector
        let bytes: Vec<u8> = vec![0, 159, 146, 150];
        let _ = TagName::try_from(bytes).unwrap();
    }

    #[test]
    fn tag_name_can_convert_valid_bytes_into_a_tag_name() -> crate::Result<()> {
        let bytes: Vec<u8> = b"PART_ENTRY_NUMBER".to_vec();
        let actual = TagName::try_from(bytes)?;
        let expected = TagName::PartEntryNumber;
        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_a_valid_label() -> crate::Result<()> {
        let label = "LABEL";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Label;
        assert_eq!(actual, expected);

        let label = "UUID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Uuid;
        assert_eq!(actual, expected);

        let label = "PARTLABEL";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartLabel;
        assert_eq!(actual, expected);

        let label = "PARTUUID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartUuid;
        assert_eq!(actual, expected);

        let label = "ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Id;
        assert_eq!(actual, expected);

        let label = "PTUUID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PtUuid;
        assert_eq!(actual, expected);

        let label = "PTTYPE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PtType;
        assert_eq!(actual, expected);

        let label = "PTMAGIC";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PtMagic;
        assert_eq!(actual, expected);

        let label = "PTMAGIC_OFFSET";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PtMagicOffset;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_TYPE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryType;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_NUMBER";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryNumber;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_UUID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryUuid;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_OFFSET";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryOffset;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_SIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntrySize;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_SCHEME";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryScheme;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_DISK";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryDisk;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_FLAGS";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryFlags;
        assert_eq!(actual, expected);

        let label = "PART_ENTRY_NAME";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PartEntryName;
        assert_eq!(actual, expected);

        let label = "ALIGNMENT_OFFSET";
        let actual = TagName::from_str(label)?;
        let expected = TagName::AlignmentOffset;
        assert_eq!(actual, expected);

        let label = "LOGICAL_SECTOR_SIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::LogicalSectorSize;
        assert_eq!(actual, expected);

        let label = "PHYSICAL_SECTOR_SIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PhysicalSectorSize;
        assert_eq!(actual, expected);

        let label = "MINIMUM_IO_SIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::MinimumIoSize;
        assert_eq!(actual, expected);

        let label = "OPTIMAL_IO_SIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::OptimalIoSize;
        assert_eq!(actual, expected);

        let label = "APPLICATION_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::ApplicationId;
        assert_eq!(actual, expected);

        let label = "BOOT_SYSTEM_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::BootSystemId;
        assert_eq!(actual, expected);

        let label = "DATA_PREPARER_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::DataPreparerId;
        assert_eq!(actual, expected);

        let label = "PUBLISHER_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PublisherId;
        assert_eq!(actual, expected);

        let label = "SYSTEM_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::SystemId;
        assert_eq!(actual, expected);

        let label = "VOLUME_SET_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::VolumeSetId;
        assert_eq!(actual, expected);

        let label = "VOLUME_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::VolumeId;
        assert_eq!(actual, expected);

        let label = "TYPE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Type;
        assert_eq!(actual, expected);

        let label = "SEC_TYPE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::SecType;
        assert_eq!(actual, expected);

        let label = "ENDIANNESS";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Endianness;
        assert_eq!(actual, expected);

        let label = "SBMAGIC";
        let actual = TagName::from_str(label)?;
        let expected = TagName::SbMagic;
        assert_eq!(actual, expected);

        let label = "SBMAGIC_OFFSET";
        let actual = TagName::from_str(label)?;
        let expected = TagName::SbMagicOffset;
        assert_eq!(actual, expected);

        let label = "SBBADCSUM";
        let actual = TagName::from_str(label)?;
        let expected = TagName::SbBadChecksum;
        assert_eq!(actual, expected);

        let label = "VERSION";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Version;
        assert_eq!(actual, expected);

        let label = "BLOCK_SIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::BlockSize;
        assert_eq!(actual, expected);

        let label = "FSBLOCKSIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::FsBlockSize;
        assert_eq!(actual, expected);

        let label = "FSSIZE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::FsSize;
        assert_eq!(actual, expected);

        let label = "FSLASTBLOCK";
        let actual = TagName::from_str(label)?;
        let expected = TagName::FsLastBlock;
        assert_eq!(actual, expected);

        let label = "USAGE";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Usage;
        assert_eq!(actual, expected);

        let label = "LABEL_RAW";
        let actual = TagName::from_str(label)?;
        let expected = TagName::LabelRaw;
        assert_eq!(actual, expected);

        let label = "UUID_RAW";
        let actual = TagName::from_str(label)?;
        let expected = TagName::UuidRaw;
        assert_eq!(actual, expected);

        let label = "EXT_JOURNAL";
        let actual = TagName::from_str(label)?;
        let expected = TagName::ExtJournal;
        assert_eq!(actual, expected);

        let label = "UUID_SUB";
        let actual = TagName::from_str(label)?;
        let expected = TagName::UuidSub;
        assert_eq!(actual, expected);

        let label = "LOGUUID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::LogUuid;
        assert_eq!(actual, expected);

        let label = "MOUNT";
        let actual = TagName::from_str(label)?;
        let expected = TagName::Mount;
        assert_eq!(actual, expected);

        let label = "LABEL_FATBOOT";
        let actual = TagName::from_str(label)?;
        let expected = TagName::LabelFatboot;
        assert_eq!(actual, expected);

        let label = "LOGICAL_VOLUME_ID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::LogicalVolumeId;
        assert_eq!(actual, expected);

        let label = "SUBSYSTEM";
        let actual = TagName::from_str(label)?;
        let expected = TagName::SubSystem;
        assert_eq!(actual, expected);

        let label = "BLOCKDEV_INITTIME";
        let actual = TagName::from_str(label)?;
        let expected = TagName::BlockdevInitTime;
        assert_eq!(actual, expected);

        let label = "BLOCKDEV_SECTORS";
        let actual = TagName::from_str(label)?;
        let expected = TagName::BlockdevSectors;
        assert_eq!(actual, expected);

        let label = "POOL_UUID";
        let actual = TagName::from_str(label)?;
        let expected = TagName::PoolUuid;
        assert_eq!(actual, expected);

        Ok(())
    }
}
